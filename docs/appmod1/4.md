# **APIs and libraries**</br>*Application Modernization - WebSphere to Liberty*

!!! quote "TERMINOLOGY"
    For readability, <a href="https://www.ibm.com/products/websphere-application-server" target="_blank">**IBM WebSphere Application Server**</a> (WAS) in this chapter is referred to in shorthand as "WebSphere", unless noted otherwise. Similarly, <a href="https://www.ibm.com/products/cloud-pak-for-applications/liberty" target="_blank">**IBM WebSphere Liberty**</a> is referenced in shorthand as simply "Liberty".
    
## **i. Incentives to modernize**

Lariat Corporation's application stack utilizes a myriad of **WebSphere Application Server APIs**— Work Manager API, Async Beans, Scheduler API, and so on —which will likely be impacted and require remediation as part of the company's overall modernization towards WebSphere Liberty. WAS APIs may not be immediately portable in their current form, they are potentially more costly to maintain than their Liberty counterparts, and may have less functionality given their outdated implementations.

Liberty-compatible APIs increase the portability of applications across different Java Enterprise Edition (*Java EE* or *Jakarta EE*) application servers. The result is that developers can more easily facilitate cloud deployments or migrations to other runtimes. Liberty APIs follow standardized annotations and conventions that simplify the boilerplate code needed for applications to exchange data with these APIs. WAS-specific APIs, by contrast, are potentially locked to specific versions of WebSphere - which in turn "lock in" those applications dependent on such APIs.

Currently, Lariat's **WAS-based APIs** rely upon IBM-specific extensions (such as `.com.ibm.websphere` packages) that will need to be identified and resolved before modernization with **Liberty-based APIs**. The shift from proprietary WAS-based APIs to standardized Liberty-based APIs (built to Jakarta EE / Java EE specifications) improves application portability and aligns with best practices.

---

## **ii. WebSphere legacy code**

First, examine the legacy Java code (below), which as mentioned previously is a snapshot of a larger WebSphere Scheduler API.

=== "WEBSPHERE APPLICATION SERVER"

    ``` java linenums="1"
    import com.ibm.websphere.scheduler.TaskHandler;
    import com.ibm.websphere.scheduler.Scheduler;
    import javax.naming.InitialContext;

    public class LegacySchedulerTask {
        public void scheduleTask() throws Exception {
            InitialContext ctx = new InitialContext();
            Scheduler scheduler = (Scheduler) ctx.lookup("scheduler/legacyScheduler");

            TaskHandler handler = scheduler.createTaskHandler(
                "TaskName",
                new LegacyTask(),
                null,
                "0 0/5 * * * ?",
                true,
                null
            );

            handler.start();
        }
    }
    ```

</br>
The `LegacySchedulerTask` API describes a WAS-specific scheduler (identifiable by the `com.ibm.websphere.scheduler` import statements on lines 1 and 2), which invokes IBM-proprietary API standards. These API invocations are in turn used to shcedule periodic task executions within Lariat's application estate.

``` java
import com.ibm.websphere.scheduler.TaskHandler;
import com.ibm.websphere.scheduler.Scheduler;
```

Utilizing WAS-specific API calls requires explicit JDNI (Java Naming and Directory Interface) look-ups. Furthermore, it demands manual intervention on the part of application developers to create and manage scheduled API tasks. The result is that this legacy API code, by placing heavy reliance upon WebSphere platform-specific APIs, has impaired the portability of their applications.

---

## **iii. Liberty modernized code**

Consider below the modernized (but functionally equivalent) Java code in support of Liberty-based APIs:

=== "WEBSPHERE LIBERTY"

    ``` java linenums="1"
    import javax.annotation.Resource;
    import javax.enterprise.context.ApplicationScoped;
    import javax.enterprise.concurrent.ManagedScheduledExecutorService;
    import java.util.concurrent.TimeUnit;

    @ApplicationScoped
    public class ModernSchedulerTask {

        @Resource
        ManagedScheduledExecutorService executor;

        public void scheduleTask() {
            executor.scheduleAtFixedRate(
                () -> {
                    // Modern task logic here
                    System.out.println("Executing scheduled task.");
                },
                0,
                5,
                TimeUnit.MINUTES
            );
        }
    }
    ```

=== "WEBSPHERE APPLICATION SERVER"

    ``` java linenums="1"
    import com.ibm.websphere.scheduler.TaskHandler;
    import com.ibm.websphere.scheduler.Scheduler;
    import javax.naming.InitialContext;

    public class LegacySchedulerTask {
        public void scheduleTask() throws Exception {
            InitialContext ctx = new InitialContext();
            Scheduler scheduler = (Scheduler) ctx.lookup("scheduler/legacyScheduler");

            TaskHandler handler = scheduler.createTaskHandler(
                "TaskName",
                new LegacyTask(),
                null,
                "0 0/5 * * * ?",
                true,
                null
            );

            handler.start();
        }
    }
    ```

</br>
In contrast to the legacy WAS-based Java API, the modernized Liberty approach (templated using Jakarta EE's API conventions) significantly simplifies the scheduling logic. The standardized `ManagedScheduledExecutorService` API for concurrency simplifies the scheduling of tasks using direct resource injection, as indicated by `@Resource` beginning on line 9.

``` java
@Resource
ManagedScheduledExecutorService executor;
```

The previous (legacy) requirement of forcing JDNI look-ups, therefore, has been remediated through the use of direct resource injection. The Jakarta EE standard also follows an annotation-driven model for scheduling tasks to reduce the overall complexity of the code and improve its "readability" for human developers.

Ultimately, the modernization efforts have significantly increased the portability and extensibility of Lariat's API-driven application estate. The structure of the API code has been simplified and made much more portable by breaking away from propriety API standards.

---

## **iv. Hands-on with WCA**



---

## **v. Next steps**


