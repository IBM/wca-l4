# **Enterprise JavaBeans (EJB) modernization**</br>*Application Modernization - WebSphere to Liberty*

!!! quote "TERMINOLOGY"
    For readability, <a href="https://www.ibm.com/products/websphere-application-server" target="_blank">**IBM WebSphere Application Server**</a> (WAS) in this chapter is referred to in shorthand as "WebSphere", unless noted otherwise. Similarly, <a href="https://www.ibm.com/products/cloud-pak-for-applications/liberty" target="_blank">**IBM WebSphere Liberty**</a> is referenced in shorthand as simply "Liberty".
    
## **i. Incentives to modernize**

WebSphere **Enterprise JavaBeans** (**EJB**) represent server-side components used by Java Enterprise Edition (*Java EE* or *Jakarta EE*) to encapsulate repeatable business logic. In turn, EJB can be used to provide scalable and highly performant handling for requests made by Lariat Corporation's web application estate. EJBs provide the resource access management for the databases, messaging services, and external APIs these such application require to power their business functions. WebSphere's EJBs make extensive use of *XML* deployment descriptors to configure their behavior.

**Liberty EJBs** use Java **annotations** instead of *XML*, applying them directly within Java classes for configuration. In many cases, this eliminates the need for external XML files completely (or at least significantly reduces their size and number).

</br>

| Feature | WebSphere EJB with XML | Liberty EJB with annotations |
| - | - | - |
| **Maintainability** | Difficult due to scattered XML configs. | Improved due to cohesive annotations. |
| **Readability** | Lower due to switching between Java and XML. | Higher due to configuration directly in Java code. |
| **Productivity** | Lower due to manual XML edits. | Higher due to rapid development through annotations. |
| **Error Propensity** | Higher chance of manual XML errors. | Lower due to clear annotations and IDE checks. |

By modernizing WebSphere's EJB's stateless session beans into **Liberty's standard-compliant EJB** will provide Lariat with the net benefit of code that's easier to maintain, more portable, and extensible to today's modern cloud-native endpoints. Ultimately, this should yield a simplified developer experience and better resource management.

---

## **ii. WebSphere legacy code**

First, examine the legacy code (below), which as mentioned previously is a snapshot of a larger application using **WebSphere's EJB Stateful Session Bean with XML**:

=== "WEBSPHERE APPLICATION SERVER"

    ``` xml linenums="1"
    <!-- ejb-jar.xml -->
    <ejb-jar>
        <enterprise-beans>
            <session>
                <ejb-name>LegacySessionBean</ejb-name>
                <home>com.lariat.ejb.LegacyHome</home>
                <remote>com.lariat.ejb.LegacyRemote</remote>
                <ejb-class>com.lariat.ejb.LegacySessionBean</ejb-class>
                <session-type>Stateless</session-type>
                <transaction-type>Container</transaction-type>
            </session>
        </enterprise-beans>
    </ejb-jar>
    ```

</br>

The legacy EJB implementation uses XML (`ejb-jar.xml` beginning on **line 1**) to explicitly define the contents of the *stateful* session bean. This requires that the `<home>` and `<remote>` interfaces be explicitly defined, along with the bean class. Transaction types and security are also configured *externally* via descriptors within the XML.

---

## **iii. Liberty modernized code**

Consider below the modernized (but functionally equivalent) application code using **Liberty's EJB Stateless Session Bean with annotations**:

=== "WEBSPHERE LIBERTY"

    ``` java linenums="1"
    package com.lariat.ejb;

    import javax.ejb.Stateless;
    import javax.ejb.Remote;

    @Stateless
    @Remote(ModernRemote.class)
    public class ModernSessionBean implements ModernRemote {

        @Override
        public String getGreeting(String name) {
            return "Hello, " + name + "!";
        }
    }

    package com.lariat.ejb;

    import javax.ejb.Remote;

    @Remote
    public interface ModernRemote {
        String getGreeting(String name);
    }
    ```

=== "WEBSPHERE APPLICATION SERVER"

    ``` xml linenums="1"
    <!-- ejb-jar.xml -->
    <ejb-jar>
        <enterprise-beans>
            <session>
                <ejb-name>LegacySessionBean</ejb-name>
                <home>com.lariat.ejb.LegacyHome</home>
                <remote>com.lariat.ejb.LegacyRemote</remote>
                <ejb-class>com.lariat.ejb.LegacySessionBean</ejb-class>
                <session-type>Stateless</session-type>
                <transaction-type>Container</transaction-type>
            </session>
        </enterprise-beans>
    </ejb-jar>
    ```

</br>

The modernized Liberty code adopts EJB with Java annotations directly within the bean implementation; for example, utilizing such annotations as `@Stateless` beginning on **line 6**:

``` java
@Stateless
@Remote(ModernRemote.class)
public class ModernSessionBean implements ModernRemote {

    @Override
    public String getGreeting(String name) {
        return "Hello, " + name + "!";
    }
}
```

</br> 

This approach also eliminates the need for explicit home interfaces, instead allowing Lariat's developers to directly specify remote interfaces within the bean definition. There are also positive side effects to the "readability" of the code â€” since transaction management and security settings are managed via annotations, the amount of XML overhead is reduced and thus the code can be more easily parsed (and maintained) by humans.

Ultimately, Liberty's modernized EJB implementation simplifies the bean declaration significantly and reduces the amount of boilerplate code necessary for the application. In turn, Lariat's code will be easier to maintain, more readable to developers, and easier to extend with capabilities over time.

---

## **iv. Hands-on with WCA**



---

## **v. Next steps**


